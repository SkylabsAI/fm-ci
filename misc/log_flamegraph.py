#!/usr/bin/env python3

# This file computes in the shape generated by `perf script` from the `.json` automation output format
# The result can be used with flamegraph-related tools. In particular, this includes profiler.firefox.com.

# USAGE:

# python3 log_flamegraph.py 9 < log.json > log.script

# `log.json` is the output of `with_log_file log.json` or `output_log_file log.json`.
# NOTE: You do not need to set any debug levels explicitly.


# COMBINING WITH PERF OUTPUT

# `perf record` data that has been generated simultaneously with automation
# logging data can be combined to be inspected together on profiler.firefox.com.
# Use `perf record -k MONOTONIC_CLOCK` to get the clocks to sync up.
# The output of `perf script` can simply be concatenated with the output of `log_flamegraph.py`:
# $ cat perf-script-output log-flamegraph-output > combined-output
# `combined-output` can then be uploaded to profiler.firefox.com

import json
import sys
import heapq
import math
import bisect

j = json.load(sys.stdin)

min_time = 1.0

class kd(object):
    # items is kept sorted by starting time and all items inhabit disjoint time spans
    __slots__ = ("key", "ctx", "start","end","items")

    def __init__(self, key, ctx, start, end, items):
        self.key = key
        self.ctx = ctx
        self.start = start
        self.end = end
        self.items = list(sorted(items,key=lambda x: (x.start,x.end)))
        # asserting disjointness
        if self.items == []:
            pass
        else:
            prev = self.items[0].end
            for item in self.items[1:]:
                assert (item.start >= prev)
                prev = item.end

    def query(self, t):
        # print(f"context: {self.ctx}", file=sys.stderr)
        # print(f"start: {self.start}",file=sys.stderr)
        # print(f"t:     {t}",file=sys.stderr)
        # print(f"end:   {self.end}",file=sys.stderr)
        if t < self.start:
            return None
        if t > self.end:
            return None
        # bisect for start value
        # i is the first index for which the right neighbour has start > t
        i = bisect.bisect_left(self.items, t, key=lambda x: x.start)
        # print(f"items: {len(self.items)}", file=sys.stderr)
        # for j, item in enumerate(self.items):
        #     print(f"item {j}: {item.start}, {item.end}", file=sys.stderr)
        # print(f"{i}", file=sys.stderr);
        if i == 0: # no items with item.start <= t
            return self
        elif self.items[i-1].end >= t:
            return self.items[i-1].query(t)
        else:
            return self

    def print(self, file=sys.stderr, indent=0):
        indentstr = " "*indent
        print(f"{indentstr}start: {self.start}", file=file)
        print(f"{indentstr}start: {self.end}", file=file)
        print(f"{indentstr}items: {len(self.items)}", file=file)
        for i in self.items:
            i.print(file=file,indent=indent+2)

intv = (1000.0/float(sys.argv[1])) if len(sys.argv) > 1 else 10

def w(j,res,ctx):
    global min_time
    global h
    if not ('name' in j):
        return None
    else:
        key = j['name']
        ctx = ctx+[key]
        if not (key in res):
            res[key] = { 'self' : 0.0, 'items': {} }
        items = ws(j['items'],res[key]['items'],ctx)
        return kd(key,ctx,j['meta']['t0'],j['meta']['t1'],items)

def ws(j,res,ctx):
    items = []
    for x in j:
        v = w(x,res,ctx)
        if v is not None:
          items.append(v)
    return items

res = {}
items = ws(j, res, [])
top = None
if len(items) == 1:
    top = items[0]
else:
    top = kd(None, [], items[0].start, items[-1].end, items)

def normalize(k, t):
    k.start = k.start - t
    k.end = k.end - t
    for item in k.items:
        normalize(item, t)

# normalize(top, top.start)

factor = 1.0/min_time if min_time < 1.0 else 1.0

def sample(intv):
    if top.items == []:
        return

    offset = top.start

    while offset < top.end:
        v = top.query(offset)
        # print(v, file=sys.stderr)
        if v == None:
            yield (offset, [])
        else:
            yield (offset, v.ctx)
        offset += intv


for time,stack in sample(intv):
    print("work 400000 %f:     1 instructions:u: " % (time/1000.0/1000.0))
    if len(stack) > 0:          # actual samples
        for i in reversed(stack):
            print("\t           10000 %s (ltac2_profiling)" % i)
    else:
        print("\t           10000 unrelated_proof_script (unrelated.ko)")
    print()
