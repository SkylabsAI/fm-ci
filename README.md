Centralized FM CI Setup
=======================

This repository documents and implements our centralized FM CI setup, based on
a standard `bhv` checkout.

The CI configuration for any other FM repository is the following.
```yaml
trigger:
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  variables:
    ORIGIN_CI_COMMIT_SHA: $CI_COMMIT_SHA
    ORIGIN_CI_COMMIT_BRANCH: $CI_COMMIT_BRANCH
    ORIGIN_CI_MERGE_REQUEST_IID: $CI_MERGE_REQUEST_IID
    ORIGIN_CI_MERGE_REQUEST_LABELS: $CI_MERGE_REQUEST_LABELS
    ORIGIN_CI_MERGE_REQUEST_PROJECT_ID: $CI_MERGE_REQUEST_PROJECT_ID
    ORIGIN_CI_MERGE_REQUEST_SOURCE_BRANCH_NAME: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    ORIGIN_CI_MERGE_REQUEST_TARGET_BRANCH_NAME: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
    ORIGIN_CI_PIPELINE_SOURCE: $CI_PIPELINE_SOURCE
    ORIGIN_CI_PIPELINE_URL: $CI_PIPELINE_URL
    ORIGIN_CI_PROJECT_PATH: $CI_PROJECT_PATH
    ORIGIN_CI_PROJECT_TITLE: $CI_PROJECT_TITLE
  trigger:
    project: bedrocksystems/formal-methods/fm-ci
    branch: main
    strategy: depend
```
This means that CI for such a repository simply triggers a pipeline on `fm-ci`
(the current repository), setting some variables identifying the provenance of
the CI request, and parameters like merge request labels. All the variables in
the trigger have their standard name, prefixed with `ORIGIN_`.

**Note:** in repositories part of a subgroup (e.g., `formal-methods`) variable
`$CI_PROJECT_TITLE` should be prefixed with the group name. For example, CI in
[formal-methods/stdpp](https://gitlab.com/bedrocksystems/formal-methods/stdpp)
requires `formal-methods/$CI_PROJECT_TITLE` instead of `$CI_PROJECT_TITLE`.

## Support for `CI::same-branch`

The `CI::same-branch` label can be set in MRs of any FM repository, and it has
the effect of selecting branches of the same name as the MR branch for all the
FM repositories in the `bhv` checkout, if such a branch exists.

Furthermore, if `fm-ci` (the current repository) has a branch of the same name
(that of the initiating MR branch), then it is also selected. When that is the
case, CI is still triggered via the `main` branch. Hence, **any changes to the
`.gitlab-ci.yml` file should be avoided** since they won't be picked up before
the branch is merged.

Note that the `.gitlab-ci.yml` file is kept as simple as possible, to make the
need for changes as unlikely as possible. It does three things:
- It checkout out another commit of `fm-ci` if necessary.
- It generates the main CI configuration (see next section).
- It triggers a child pipeline with the generated configuration.

## CI Configuration Generation

The main CI configuration is generated by calling:
```sh
dune exec -- ./gen/gen.exe ${CI_JOB_TOKEN} repos.conf gen-config.yml
```
This program takes as input a GitLab token, a configuration file `repos.conf`,
and it outputs a YAML file `gen-config.yml` that is used in a child pipeline.

The configuration file `repos.conf` gives the list of FM repositories, as well
as their relative path in a `bhv` checkout, the name of their main branch, and
the list of FM repositories they depend on.

The generation process is documented in the various OCaml files, the main file
being `gen/gen.ml`.

## Support for `FM-CI-Compare`

The `FM-CI-Compare` label can be set in MRs of any FM repository, so as to run
a performance comparison. The label only affects the main building job, called
`full-build-compare` when the label is set, and `full-build` otherwise.

When the label is set, the CI configuration generation script must determine a
reference branch for all involved repositories (either just the one triggering
the pipeline in the originating MR, or potentially several repositories if the
`CI::same-branch` label is also set). For other repositories, the reference is
simply their main branch (as specified in the configuration file). For all the
involved repositories, the reference commit is defined as the `git merge-base`
of the main branch and the MR branch.

The `full-build-compare` job proceeds as follows:
1. Clone `bhv` and checkout the branch for the main build.
2. Run `make init` and checkout the main build commits for all sub-repos.
3. Run the build, and copy the resulting `_build` folder.
4. Run `make gitclean` and checkout the reference build commits for all repos.
5. Run the build, and copy the resulting `_build` folder as well.
6. Run `make gitclean` again, and checkout the main build commits again.
7. Generate the performance data based on the two copied `_build` folders.

Note that step 3 is allowed to fail, but we remember its status so that we can
make the full job fail accordingly when the end of the job is reached. This is
useful to get partial performance data even if not all files build. Unlike the
main build, the reference build is not allowed to fail.

## Support for "Non-Main" MR Targets

When an MR targets a branch that is different from the configured repository's
main branch, the reference commit used for performance comparison is chosen to
be that of the target branch (or a merge base of that and the MR branch). When
`CI::same-branch` is set, the reference commit for repos that did not initiate
the MR is taken from a branch with the same name, if it exists. Otherwise, the
reference is taken to be the main branch.

## Possible improvements

### Support `CI::same-branch` When the Config Changes

This is only relevant when there is an `fm-ci` branch. In that case, we should
inspect the repos configuration of both `main`, and the branch, since they may
not have the same set of repositories.

The logic then needs to be changed in the `full-build-compare` job, so that we
run `make init` for `bhv` also for the reference build.
